import { describe, expect } from 'vitest';
import * as byegl from '../src/index.ts';
import { extractAccessPath } from '../src/uniform.ts';
import { test } from './extendedTest.ts';

describe('float uniform', () => {
  test('shader generation', ({ gl }) => {
    const glslVert = `
      uniform float uFoo;
    `;

    const glslFrag = `
      uniform float uBar;
    `;

    const vert = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vert, glslVert);
    const frag = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(frag, glslFrag);
    const program = gl.createProgram();
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);

    expect(byegl.getWGSLSource(gl, program)).toMatchInlineSnapshot(`
      "// Generated by byegl

      var<private> gl_Position: vec4<f32>;
      var<private> gl_FragColor: vec4<f32>;

      @group(0) @binding(0) var<uniform> uFoo: f32;
      @group(0) @binding(1) var<uniform> uBar: f32;

      struct _byegl_VertexOut_2 {
        @builtin(position) _byegl_posOut_3: vec4f,

      }


      @vertex
      fn _byegl_vert_main_4() -> _byegl_VertexOut_2 {


        _byegl_fake_vertex_0();
        var output: _byegl_VertexOut_2;
        output._byegl_posOut_3 = gl_Position;
        // NOTE: OpenGL uses z in the range [-1, 1], while WebGPU uses z in the range [0, 1].
        output._byegl_posOut_3.z = output._byegl_posOut_3.z * 0.5 + 0.5;

        return output;
      }

      @fragment
      fn _byegl_frag_main_5() -> @location(0) vec4f {
        // Filling proxies with varying data

        _byegl_fake_fragment_1();
        return gl_FragColor;
      }
      "
    `);
  });
});

describe('extractAccessPath', () => {
  test('simple uniform name', () => {
    expect(extractAccessPath('uniformName')).toEqual(['uniformName']);
  });

  test('uniform with array index', () => {
    expect(extractAccessPath('uniformName[0]')).toEqual(['uniformName', 0]);
  });

  test('uniform with property access', () => {
    expect(extractAccessPath('uniformName.subUniform')).toEqual([
      'uniformName',
      'subUniform',
    ]);
  });

  test('uniform with array index and property access', () => {
    expect(extractAccessPath('uniformName[0].subUniform')).toEqual([
      'uniformName',
      0,
      'subUniform',
    ]);
  });

  test('uniform with multiple array indices', () => {
    expect(extractAccessPath('uniformName[0][1]')).toEqual([
      'uniformName',
      0,
      1,
    ]);
  });

  test('uniform with nested property access', () => {
    expect(extractAccessPath('uniformName.prop1.prop2')).toEqual([
      'uniformName',
      'prop1',
      'prop2',
    ]);
  });

  test('uniform with mixed array and property access', () => {
    expect(extractAccessPath('uniformName[1].prop[2].subProp')).toEqual([
      'uniformName',
      1,
      'prop',
      2,
      'subProp',
    ]);
  });

  test('empty string', () => {
    expect(extractAccessPath('')).toBeUndefined();
  });

  test('string with only separators', () => {
    expect(extractAccessPath('...')).toBeUndefined();
  });

  test('string with only brackets', () => {
    expect(extractAccessPath('[]')).toBeUndefined();
  });

  test('large array index', () => {
    expect(extractAccessPath('uniformName[999]')).toEqual(['uniformName', 999]);
  });

  test('zero index', () => {
    expect(extractAccessPath('uniformName[0]')).toEqual(['uniformName', 0]);
  });
});
