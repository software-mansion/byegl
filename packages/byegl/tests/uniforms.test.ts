import { describe, expect } from 'vitest';
import * as byegl from '../src/index.ts';
import { $internal } from '../src/types.ts';
import { ByeGLUniformLocation } from '../src/uniform.ts';
import { test, toWgsl } from './extendedTest.ts';

function extractUniformInfo(location: WebGLUniformLocation | null) {
  if (!location) {
    return null;
  }
  const internal = (location as ByeGLUniformLocation)[$internal];

  return {
    location: internal.baseInfo.location,
    byteOffset: internal.byteOffset,
    dataType: String(internal.dataType),
  };
}

describe('float uniform', () => {
  test('shader generation', ({ gl }) => {
    const glslVert = `
      uniform float uFoo;
    `;

    const glslFrag = `
      uniform float uBar;
    `;

    const { wgsl } = toWgsl(gl, glslVert, glslFrag);

    expect(wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl



      @group(0) @binding(0) var<uniform> uFoo: f32;
      @group(0) @binding(1) var<uniform> uBar: f32;

      var<private> gl_Position: vec4f;
      var<private> gl_FrontFacing: bool;
      var<private> gl_FragColor: vec4f;
      "
    `);
  });
});

describe('getUniformLocation', () => {
  test('basic uniform location', ({ gl }) => {
    const glslVert = `
      uniform float u_foo;
    `;

    const glslFrag = `
      uniform float u_bar;
      uniform vec3 u_vec3;
      uniform mat4 u_mat4;

      void main() {
        gl_FragColor = vec4(u_bar + u_foo + u_vec3.x + u_mat4[0][0]);
      }
    `;

    const { program } = toWgsl(gl, glslVert, glslFrag);

    // Test basic uniform access
    const fooLocation = gl.getUniformLocation(program, 'u_foo');
    expect(extractUniformInfo(fooLocation)).toMatchInlineSnapshot(`
      {
        "byteOffset": 0,
        "dataType": "f32Cast",
        "location": 0,
      }
    `);

    // Test vec3 uniform access
    const vec3Location = gl.getUniformLocation(program, 'u_vec3');
    expect(extractUniformInfo(vec3Location)).toMatchInlineSnapshot(`
      {
        "byteOffset": 0,
        "dataType": "vec3f",
        "location": 2,
      }
    `);

    // Test mat4 uniform access
    const mat4Location = gl.getUniformLocation(program, 'u_mat4');
    expect(mat4Location).not.toBeNull();
    expect(extractUniformInfo(mat4Location)).toMatchInlineSnapshot(`
      {
        "byteOffset": 0,
        "dataType": "mat4x4f",
        "location": 3,
      }
    `);
  });

  test('array and struct access', ({ gl }) => {
    const glsl = `
      precision mediump float;

      struct Light {
        vec3 position;
        vec3 color;
      };

      uniform Light u_light[2];
      uniform vec3 u_colors[2];

      void main() {
        // Use the uniforms to ensure they're not optimized away
        vec3 color = u_light[0].color + u_light[1].color + u_colors[0] + u_colors[1];
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    const { program } = toWgsl(gl, glsl);

    // Structs themselves don't get locations, only primitives
    expect(
      extractUniformInfo(gl.getUniformLocation(program, 'u_light[0]')),
    ).toMatchInlineSnapshot(`null`);

    expect(
      extractUniformInfo(gl.getUniformLocation(program, 'u_light[0].position')),
    ).toMatchInlineSnapshot(`
      {
        "byteOffset": 0,
        "dataType": "vec3f",
        "location": 0,
      }
    `);

    expect(
      extractUniformInfo(gl.getUniformLocation(program, 'u_light[1].color')),
    ).toMatchInlineSnapshot(`
      {
        "byteOffset": 48,
        "dataType": "vec3f",
        "location": 0,
      }
    `);

    expect(
      extractUniformInfo(gl.getUniformLocation(program, 'u_colors[0]')),
    ).toMatchInlineSnapshot(`
      {
        "byteOffset": 0,
        "dataType": "vec3f",
        "location": 1,
      }
    `);

    expect(
      extractUniformInfo(gl.getUniformLocation(program, 'u_colors[1]')),
    ).toMatchInlineSnapshot(`
      {
        "byteOffset": 16,
        "dataType": "vec3f",
        "location": 1,
      }
    `);
  });
});
