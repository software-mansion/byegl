import { describe, expect } from 'vitest';
import * as byegl from '../src/index.ts';
import { test } from './extendedTest.ts';

describe('float uniform', () => {
  test('shader generation', ({ gl }) => {
    const glslVert = `
      uniform float uFoo;
    `;

    const glslFrag = `
      uniform float uBar;
    `;

    const vert = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vert, glslVert);
    const frag = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(frag, glslFrag);
    const program = gl.createProgram();
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);

    expect(byegl.getWGSLSource(gl, program)).toMatchInlineSnapshot(`
      "// Generated by byegl

      var<private> gl_Position: vec4<f32>;
      var<private> gl_FragColor: vec4<f32>;

      @group(0) @binding(0) var<uniform> uFoo: f32;
      @group(0) @binding(1) var<uniform> uBar: f32;

      struct _byegl_VertexOut_2 {
        @builtin(position) _byegl_posOut_3: vec4f,

      }


      @vertex
      fn _byegl_vert_main_4() -> _byegl_VertexOut_2 {


        _byegl_fake_vertex_0();
        var output: _byegl_VertexOut_2;
        output._byegl_posOut_3 = gl_Position;
        // NOTE: OpenGL uses z in the range [-1, 1], while WebGPU uses z in the range [0, 1].
        output._byegl_posOut_3.z = output._byegl_posOut_3.z * 0.5 + 0.5;

        return output;
      }

      @fragment
      fn _byegl_frag_main_5() -> @location(0) vec4f {
        // Filling proxies with varying data

        _byegl_fake_fragment_1();
        return gl_FragColor;
      }
      "
    `);
  });
});

describe('WGSL Generator - separate function names ', () => {
  test('Produce vertex and fragment functions', ({ gl }) => {
    const glslVert = `
      float foo() { return 1.0; }
      void main() { gl_Position = vec4(foo()); }
    `;
    const glslFrag = `
      float foo() { return 2.0; }
      void main() { gl_FragColor = vec4(foo()); }
    `;

    const vert = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vert, glslVert);
    const frag = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(frag, glslFrag);
    const program = gl.createProgram();
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);

    const wgsl = byegl.getWGSLSource(gl, program);

    expect(wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl

      var<private> gl_Position: vec4<f32>;
      var<private> gl_FragColor: vec4<f32>;


      fn foo_vert() -> f32 {
        return 1.0;
      }
      
      fn _byegl_fake_vertex_0() {
        gl_Position = vec4f(foo_vert());
      }

      fn foo_frag() -> f32 {
        return 2.0;
      }

      fn _byegl_fake_fragment_1() {
        gl_FragColor = vec4f(foo_frag());
      }

      struct _byegl_VertexOut_2 {
        @builtin(position) _byegl_posOut_3: vec4f,
      
      }
      
      
      @vertex
      fn _byegl_vert_main_4() -> _byegl_VertexOut_2 {


        _byegl_fake_vertex_0();
        var output: _byegl_VertexOut_2;
        output._byegl_posOut_3 = gl_Position;
        // NOTE: OpenGL uses z in the range [-1, 1], while WebGPU uses z in the range [0, 1].
        output._byegl_posOut_3.z = output._byegl_posOut_3.z * 0.5 + 0.5;
      
        return output;
      }

      @fragment
      fn _byegl_frag_main_5() -> @location(0) vec4f {
        // Filling proxies with varying data
      
        _byegl_fake_fragment_1();
        return gl_FragColor;
      }
      "
    `);
  });
});
