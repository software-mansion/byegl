import { describe, expect } from 'vitest';
import * as byegl from '../src/index.ts';
import { test, toWgsl } from './extendedTest.ts';

describe('arrays', () => {
  test('shader generation', ({ gl }) => {
    const glslFrag = `
      uniform float uFoo[4];

      struct Light {
        vec3 position;
        vec3 color;
      };

      uniform Light u_lights[3];
    `;

    const vert = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vert, '');
    const frag = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(frag, glslFrag);
    const program = gl.createProgram();
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);

    expect(gl.getProgramInfoLog(program)).toMatchInlineSnapshot(`""`);

    expect(byegl.getWGSLSource(gl, program)).toMatchInlineSnapshot(`
      "// Generated by byegl

      struct Light_0 {
        position: vec3f,
        color: vec3f,
      }var<private> gl_Position: vec4<f32>;
      var<private> gl_FragColor: vec4<f32>;

      @group(0) @binding(0) var<uniform> uFoo: array<f32, 4>;
      @group(0) @binding(1) var<uniform> u_lights: array<Light_0, 3>;

      struct _byegl_VertexOut_2 {
        @builtin(position) _byegl_posOut_3: vec4f,

      }


      @vertex
      fn _byegl_vert_main_4() -> _byegl_VertexOut_2 {


        _byegl_fake_vertex_0();
        var output: _byegl_VertexOut_2;
        output._byegl_posOut_3 = gl_Position;
        // NOTE: OpenGL uses z in the range [-1, 1], while WebGPU uses z in the range [0, 1].
        output._byegl_posOut_3.z = output._byegl_posOut_3.z * 0.5 + 0.5;

        return output;
      }

      @fragment
      fn _byegl_frag_main_5() -> @location(0) vec4f {
        // Filling proxies with varying data

        _byegl_fake_fragment_1();
        return gl_FragColor;
      }
      "
    `);
  });
});

describe('for statements', () => {
  test('from 0 to 5', ({ gl }) => {
    const glsl = `
      void main() {
        vec3 color = vec3(0);
        for (int i = 0; i < 4; i++) {
          color += vec3(i, i + 1, i + 2);
        }
      }
    `;

    expect(toWgsl(gl, glsl)).toMatchInlineSnapshot(`
      "// Generated by byegl

      var<private> gl_Position: vec4<f32>;
      var<private> gl_FragColor: vec4<f32>;


      fn _byegl_fake_fragment_1() {
        var color: vec3f = vec3f(0);
        for (var i: i32 = 0; i < 4; i++) {
          color += vec3f(i, i + 1, i + 2);
        }
      }

      struct _byegl_VertexOut_2 {
        @builtin(position) _byegl_posOut_3: vec4f,

      }


      @vertex
      fn _byegl_vert_main_4() -> _byegl_VertexOut_2 {


        _byegl_fake_vertex_0();
        var output: _byegl_VertexOut_2;
        output._byegl_posOut_3 = gl_Position;
        // NOTE: OpenGL uses z in the range [-1, 1], while WebGPU uses z in the range [0, 1].
        output._byegl_posOut_3.z = output._byegl_posOut_3.z * 0.5 + 0.5;

        return output;
      }

      @fragment
      fn _byegl_frag_main_5() -> @location(0) vec4f {
        // Filling proxies with varying data

        _byegl_fake_fragment_1();
        return gl_FragColor;
      }
      "
    `);
  });
});
