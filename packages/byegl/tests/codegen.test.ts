import { describe, expect } from 'vitest';
import { test, toWgsl } from './extendedTest.ts';

describe('arrays', () => {
  test('shader generation', ({ gl }) => {
    const glsl = `
      uniform float uFoo[4];

      struct Light {
        vec3 position;
        vec3 color;
      };

      uniform Light u_lights[3];
    `;

    expect(toWgsl(gl, glsl).wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl

      struct Light_0 {
        position: vec3f,
        color: vec3f,
      }
      struct _Uniforms {
        @align(16) uFoo: array<f32, 4>,
        @align(16) u_lights: array<Light_0, 3>,
      }
      @group(0) @binding(0) var<uniform> _uniforms: _Uniforms;




      var<private> gl_Position: vec4f;
      var<private> gl_FrontFacing: bool;
      var<private> gl_FragColor: vec4f;
      "
    `);
  });

  test('used as parameters', ({ gl }) => {
    const glsl = `
      vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[9] ) {
        float x = normal.x, y = normal.y, z = normal.z;
        vec3 result = shCoefficients[0] * 0.886227;
        result += shCoefficients[1] * 2.0 * 0.511664 * y;
        result += shCoefficients[2] * 2.0 * 0.511664 * z;
        result += shCoefficients[3] * 2.0 * 0.511664 * x;
        result += shCoefficients[4] * 2.0 * 0.429043 * x * y;
        result += shCoefficients[5] * 2.0 * 0.429043 * y * z;
        result += shCoefficients[6] * ( 0.743125 * z * z - 0.247708 );
        result += shCoefficients[7] * 2.0 * 0.429043 * x * z;
        result += shCoefficients[8] * 0.429043 * ( x * x - y * y );
        return result;
      }
    `;

    expect(toWgsl(gl, glsl).wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl




      fn shGetIrradianceAt(normal: vec3f, shCoefficients: array<vec3f, 9>) -> vec3f {
        var x: f32 = normal.x;
        var y: f32 = normal.y;
        var z: f32 = normal.z;
        var result: vec3f = shCoefficients[0] * 0.886227;
        result += shCoefficients[1] * 2.0 * 0.511664 * y;
        result += shCoefficients[2] * 2.0 * 0.511664 * z;
        result += shCoefficients[3] * 2.0 * 0.511664 * x;
        result += shCoefficients[4] * 2.0 * 0.429043 * x * y;
        result += shCoefficients[5] * 2.0 * 0.429043 * y * z;
        result += shCoefficients[6] * (0.743125 * z * z - 0.247708);
        result += shCoefficients[7] * 2.0 * 0.429043 * x * z;
        result += shCoefficients[8] * 0.429043 * (x * x - y * y);
        return result;
      }

      var<private> gl_Position: vec4f;
      var<private> gl_FrontFacing: bool;
      var<private> gl_FragColor: vec4f;
      "
    `);
  });
});

describe('for statements', () => {
  test('from 0 to 5', ({ gl }) => {
    const glsl = `
      void main() {
        vec3 color = vec3(0);
        for (int i = 0; i < 4; i++) {
          color += vec3(i, i + 1, i + 2);
        }
      }
    `;

    expect(toWgsl(gl, glsl).wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl




      fn _byegl_fake_fragment_0() {
        var color: vec3f = vec3f(0);
        for (var i: i32 = 0; i < 4; i++) {
          color += vec3f(i, i + 1, i + 2);
        }
      }

      var<private> gl_Position: vec4f;
      var<private> gl_FrontFacing: bool;
      var<private> gl_FragColor: vec4f;

      struct _byegl_FragmentIn_1 {
        @builtin(front_facing) _byegl_frontFacing_2: bool,

      }


      @fragment
      fn _byegl_frag_main_3(input: _byegl_FragmentIn_1) -> @location(0) vec4f {
        // Filling proxies with varying data
        gl_FrontFacing = input._byegl_frontFacing_2;

        _byegl_fake_fragment_0();
        return gl_FragColor;
      }
      "
    `);
  });
});

describe('out parameters', () => {
  test('shader generation', ({ gl }) => {
    const glsl = `
      float myFunction(float a, float b, out float rem) {
        rem = max(0.0, a - b);
        return max(0.0, b - a);
      }

      void main() {
        float result, remainder;
        result = myFunction(5.0, 3.0, remainder);
      }
    `;

    expect(toWgsl(gl, glsl).wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl




      fn myFunction(a: f32, b: f32, rem: ptr<function, f32>) -> f32 {
        *rem = max(0.0, a - b);
        return max(0.0, b - a);
      }

      fn _byegl_fake_fragment_1() {
        var result: f32;
        var remainder: f32;
        result = myFunction(5.0, 3.0, &remainder);
      }

      var<private> gl_Position: vec4f;
      var<private> gl_FrontFacing: bool;
      var<private> gl_FragColor: vec4f;

      struct _byegl_FragmentIn_2 {
        @builtin(front_facing) _byegl_frontFacing_3: bool,

      }


      @fragment
      fn _byegl_frag_main_4(input: _byegl_FragmentIn_2) -> @location(0) vec4f {
        // Filling proxies with varying data
        gl_FrontFacing = input._byegl_frontFacing_3;

        _byegl_fake_fragment_1();
        return gl_FragColor;
      }
      "
    `);
  });
});

describe('preprocessor directives', () => {
  test('#if #else #endif', ({ gl }) => {
    const glslTrue = `
#define HELLO

#if defined(HELLO)
uniform float foo;
#else
uniform int foo;
#endif
`;

    const glslFalse = `
#if defined(HELLO)
uniform float foo;
#else
uniform int foo;
#endif
`;

    expect(toWgsl(gl, glslTrue).wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl


      struct _Uniforms {
        @align(16) foo: f32,
      }
      @group(0) @binding(0) var<uniform> _uniforms: _Uniforms;




      var<private> gl_Position: vec4f;
      var<private> gl_FrontFacing: bool;
      var<private> gl_FragColor: vec4f;
      "
    `);

    expect(toWgsl(gl, glslFalse).wgsl).toMatchInlineSnapshot(`
      "// Generated by byegl


      struct _Uniforms {
        @align(16) foo: i32,
      }
      @group(0) @binding(0) var<uniform> _uniforms: _Uniforms;




      var<private> gl_Position: vec4f;
      var<private> gl_FrontFacing: bool;
      var<private> gl_FragColor: vec4f;
      "
    `);
  });
});
